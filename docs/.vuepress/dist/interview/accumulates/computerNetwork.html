<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机网络 | WW&#39;s blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/assets/images/favicon.ico">
    <meta name="description" content="小万的学习日记">
    
    <link rel="preload" href="/assets/css/0.styles.f906e04f.css" as="style"><link rel="preload" href="/assets/js/app.b204aa68.js" as="script"><link rel="preload" href="/assets/js/3.11858a94.js" as="script"><link rel="preload" href="/assets/js/41.74542fa5.js" as="script"><link rel="prefetch" href="/assets/js/10.4ba6d33d.js"><link rel="prefetch" href="/assets/js/11.25404561.js"><link rel="prefetch" href="/assets/js/12.c5f7c57a.js"><link rel="prefetch" href="/assets/js/13.b3f4b8fa.js"><link rel="prefetch" href="/assets/js/14.46540222.js"><link rel="prefetch" href="/assets/js/15.97723425.js"><link rel="prefetch" href="/assets/js/16.d39c92ed.js"><link rel="prefetch" href="/assets/js/17.1270b2cb.js"><link rel="prefetch" href="/assets/js/18.4979c0d3.js"><link rel="prefetch" href="/assets/js/19.0e93150c.js"><link rel="prefetch" href="/assets/js/2.4e92778c.js"><link rel="prefetch" href="/assets/js/20.a615aa84.js"><link rel="prefetch" href="/assets/js/21.991fd6a0.js"><link rel="prefetch" href="/assets/js/22.887e4024.js"><link rel="prefetch" href="/assets/js/23.eed1eb86.js"><link rel="prefetch" href="/assets/js/24.f6f628c5.js"><link rel="prefetch" href="/assets/js/25.e0c52e81.js"><link rel="prefetch" href="/assets/js/26.d0698039.js"><link rel="prefetch" href="/assets/js/27.377a3e91.js"><link rel="prefetch" href="/assets/js/28.95fa210b.js"><link rel="prefetch" href="/assets/js/29.f06819f4.js"><link rel="prefetch" href="/assets/js/30.6d27df40.js"><link rel="prefetch" href="/assets/js/31.56562f0a.js"><link rel="prefetch" href="/assets/js/32.8a12d07b.js"><link rel="prefetch" href="/assets/js/33.b1f03f72.js"><link rel="prefetch" href="/assets/js/34.769a69e9.js"><link rel="prefetch" href="/assets/js/35.4b6a6416.js"><link rel="prefetch" href="/assets/js/36.82131ca9.js"><link rel="prefetch" href="/assets/js/37.a00ea343.js"><link rel="prefetch" href="/assets/js/38.56b3fee1.js"><link rel="prefetch" href="/assets/js/39.1c786cf3.js"><link rel="prefetch" href="/assets/js/4.20549dd4.js"><link rel="prefetch" href="/assets/js/40.e55e5d14.js"><link rel="prefetch" href="/assets/js/42.5ac0cd94.js"><link rel="prefetch" href="/assets/js/43.37703fe3.js"><link rel="prefetch" href="/assets/js/44.bb3c609d.js"><link rel="prefetch" href="/assets/js/45.84d753d2.js"><link rel="prefetch" href="/assets/js/46.f5182ee4.js"><link rel="prefetch" href="/assets/js/47.410f1d3f.js"><link rel="prefetch" href="/assets/js/48.57f15450.js"><link rel="prefetch" href="/assets/js/49.8536be33.js"><link rel="prefetch" href="/assets/js/5.67ea1406.js"><link rel="prefetch" href="/assets/js/50.4285cc53.js"><link rel="prefetch" href="/assets/js/6.eb70783c.js"><link rel="prefetch" href="/assets/js/7.0c2fc075.js"><link rel="prefetch" href="/assets/js/8.c43d5f7e.js"><link rel="prefetch" href="/assets/js/9.63f08a56.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f906e04f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">WW's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/accumulate/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="/internship/" class="nav-link">
  实习日记
</a></div><div class="nav-item"><a href="/interview/accumulates/html.html" class="nav-link">
  面试总结
</a></div><div class="nav-item"><a href="https://github.com/Elvira-wan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  gitgub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/accumulate/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="/internship/" class="nav-link">
  实习日记
</a></div><div class="nav-item"><a href="/interview/accumulates/html.html" class="nav-link">
  面试总结
</a></div><div class="nav-item"><a href="https://github.com/Elvira-wan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  gitgub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>基础原理积累</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/accumulates/html.html" class="sidebar-link">HTML</a></li><li><a href="/interview/accumulates/css.html" class="sidebar-link">CSS</a></li><li><a href="/interview/accumulates/js.html" class="sidebar-link">JavaScript</a></li><li><a href="/interview/accumulates/optimize.html" class="sidebar-link">前端性能优化</a></li><li><a href="/interview/accumulates/react.html" class="sidebar-link">React</a></li><li><a href="/interview/accumulates/computerNetwork.html" aria-current="page" class="active sidebar-link">计算机网络</a></li><li><a href="/interview/accumulates/webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/interview/accumulates/ajax.html" class="sidebar-link">AJAX</a></li><li><a href="/interview/accumulates/nodeJS.html" class="sidebar-link">NodeJS</a></li><li><a href="/interview/accumulates/computerBasic.html" class="sidebar-link">计算机基础</a></li><li><a href="/interview/accumulates/func.html" class="sidebar-link">一些需要手写的函数</a></li></ul></section></li><li><a href="/interview/summarize.html" class="sidebar-link">秋招复盘</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="计算机网络"><a href="#计算机网络" class="header-anchor">#</a> 计算机网络</h1> <hr> <ul><li><p>TCP的三次握手和四次挥手</p></li> <li><p>输入url之后发生的事情以及浏览器渲染原理(DNS解析 HTTP握手 渲染什么的都仔细问了)</p> <ol><li><p>解析 URL (协议 + 域名 + 数据源文件路径名)；</p></li> <li><p>DNS域名查询，获取 IP 地址；</p></li> <li><p>根据 IP 地址找到服务器，TCP 三次握手进行连接；</p></li> <li><p>发送 HTTP 请求，请求页面资源；</p></li> <li><p>收到 HTTP 响应，获取页面资源；</p></li> <li><p>浏览器是渲染页面：</p> <ul><li><p>解析HTML文件，创建DOM树自上而下，遇到任何 脚本 与 样式都会阻塞 (外部样式不阻塞，后续外部脚本加载)；</p></li> <li><p>解析 CSS 优先级：浏览器默认设置 &lt; 用户设置 &lt; 外部样式 &lt; 内联样式 &lt; HTML中的style 样式；</p></li> <li><p>将 CSS 与 DOM 合并，构建渲染树，DOM树 与 HTML 一 一对应，渲染树会忽略设置了 <code>display: none</code> 等样式的元素；</p></li> <li><p>布局和绘制，重绘和重排：</p></li></ul></li></ol></li> <li><p>URL里每部分是什么</p></li> <li><p>get和post的区别</p> <ol><li><p>get的传参方式是通过地址栏url传参，是直接可视的，post传参是将参数放在body内传输；</p></li> <li><p>get因为通过url传输因此大小受到限制，url最大长度为2048个字符，post则无长度限制；</p></li> <li><p>get请求有幂等性，post请求每次提交新数组，并不是安全且幂等的；</p></li> <li><p>get请求可以被缓存，post请求不可以被缓存；</p></li> <li><p>get请求只支持url编码，post请求支持多种编码方式 (application/x-www-form-urlencoded，multipart/form-data，application/json， text/xml)；</p></li> <li><p>get的请求记录会留在浏览器中，post不会；</p></li> <li><p>get只支持ASCII字符，post没有字符类型限制；</p></li></ol></li> <li><p>网络请求的响应状态码：</p> <p><img src="image-20210715011319577.png" alt="image-20210715011319577"></p> <ul><li><p>**1xx：**属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。</p></li> <li><p>**2xx：**表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</p> <ul><li>「200 OK」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body 数据。</li> <li>「204 No Content」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li> <li>「<strong>206 Partial Content</strong>」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽是其中的⼀部分，也是服务器处理成功的状态。</li></ul></li> <li><p>**3xx：**表示客户端请求的资源发送了变动，需要客户端⽤新的 URL 新发送请求获取资源，也就是重定向。</p> <ul><li>「301 Moved Permanently」表示永久᯿定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。</li> <li>「302 Found」表示临时定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。</li></ul> <p>301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动᯿定向新的 URL。</p> <ul><li>「304 Not Modified」不具有跳转的含义，表示资源未修改，定向已存在的缓冲⽂件，也称缓存定向，⽤于缓存控制。</li></ul></li> <li><p>**4xx：**表示客户端发送的报⽂有误，服务器⽆法处理，也就是错误码的含义。</p> <ul><li>「400 Bad Request」表示客户端请求的报⽂有错误，但只是个笼统的错误。</li> <li>「403 Forbidden」表示服务器禁⽌访问资源，并不是客户端的请求出错。</li> <li>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。</li></ul></li> <li><p>**5xx：**表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。</p> <ul><li><p>「500 Internal Server Error」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。</p></li> <li><p>「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。</p></li> <li><p>「502 Bad Gateway」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器发⽣了错误。</p></li> <li><p>「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后重试”的意思</p></li></ul></li></ul></li> <li><p>304什么意思？也就是要讲讲http 缓存机制</p></li> <li><p>HTTP 1.1/ HTTP 2 .... 区别</p></li> <li><p>http2.0有什么缺点？为什么会有http3.0？</p></li> <li><p>HTTP的理解</p></li> <li><p><code>cookie</code> 携带在哪里发送，以及其常见属性</p></li> <li><p>HTTP 常见请求头</p> <ol><li><p><code>accept</code>：浏览器可接受的服务器返回类型</p></li> <li><p><code>accept-encoding</code>：浏览器声明可接受的编码压缩方法(gzip)；</p></li> <li><p><code>accept-language</code>：浏览器声明自己接收的语言；</p></li> <li><p><code>connection</code>：指定是否使用长连接 (keep-alive)；</p></li> <li><p><code>referer</code>：字段，告诉服务器此请求来自哪个页面链接；</p></li> <li><p><code>host</code>：指定被请求资源所在域名；</p></li> <li><p><code>cookie</code>：用来存储用户信息；</p></li> <li><p><code>User-Agent</code>：客户端使用的操作系统版本以及浏览器的名称和版本；</p></li> <li><p><code>Cache-Control</code>：缓存控制</p> <p><img src="20180921155944100" alt="img"></p></li></ol></li> <li><p>HTTP 常见响应头</p> <ol><li><p><code>Cache-Control</code>：对应请求中的Cache-Control</p> <p><img src="2018092116013247" alt="在这里插入图片描述"></p></li> <li><p><code>Last-Modified</code>：表示所请求的响应对象最后的修改时间；</p></li> <li><p><code>Etag</code>：类似于一个html文件的摘要，服务器会将请求收到的 <code>Etag</code>，与响应的 <code>Etag</code> 进行对比，判断文件是否变化，是否可以继续读取缓存中的页面；</p></li> <li><p><code>Content-Type</code>：告诉客户端，资源文件的类型和字符编码类型；</p></li> <li><p><code>Content-Encoding</code>：对应 <code>Accept-Encoding</code>，表示编码的压缩方法；</p></li> <li><p><code>Date</code>：服务器发送资源时的时间；</p></li> <li><p><code>Expires</code>：缓存相关响应头，表示缓存保存的最大时间，但该响应头没有 <code>Cache-Control: max-age</code> 准确，因为那是相对时间，而该字段只能设置绝对时间；</p></li> <li><p><code>Connection</code>：与请求头中 <code>Connection</code> 对应，也回应 <code>keep-alive</code>;</p></li> <li><p><code>Refresh</code>：用于重定向，返回重定向时间以及重定向网址；</p></li> <li><p><code>Access-Control-Allow-Origin</code> / <code>Access-Control-Allow-Methods</code> / <code>Access-Control-Allow-Credentials</code>：允许跨域的三个响应头；</p></li></ol></li> <li><p>什么是跨域，如何请求跨域资源？</p> <p>由于浏览器的同源策略，凡是发送请求 url 的协议，域名，端口三者之间任一与当前页面地址不同即为跨域：</p> <ol><li>网络协议不同：http 和 https；</li> <li>端口不同：3000 访问 5000；</li> <li>域名不同：www.youzan.com 访问 open.weixin.com；</li> <li>子域名不同：zhifuyun.youzan.com 访问 store.youzan,com；</li></ol> <p>实现跨域的方法：</p> <ul><li><p><code>proxy</code> 代理：将请求发送给中间的代理服务器，由代理服务器去转发请求 (因为服务器不存在跨域情况)，请求到的结果也会先发给代理服务器，再由代理服务器提供给当前页面；</p> <p>在生产环境中，常使用在 <code>package.lock.json</code> 中配置  <code>proxy</code>(配置单个代理) 或 <code>src</code> 下创建 <code>setupProxy</code> (配置多个代理)；</p> <p>在打包环境中，常用 <code>nginx</code>;</p></li> <li><p>CORS：在后台处理请求时，增加允许跨服的语句；</p> <p><code>Access-Control-Allow-Origin</code></p> <p><code>Access-Control-Allow-Methods</code></p> <p><code>Access-Control-Allow-Header</code></p></li> <li><p><code>jsonp</code>：利用了 <code>script</code> 标签的 <code>src</code> 不受浏览器同源策略的影响，允许跨域引用资源的性质进行跨域，当前较为流行，但只支持Get请求；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1. 定义一个 回调函数 handleResponse 用来接收返回的数据</span>
<span class="token keyword">function</span> <span class="token function">handleResponse</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 2. 动态创建一个 script 标签，并且告诉后端回调函数名叫 handleResponse</span>
<span class="token keyword">var</span> body <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">gerElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://www.laixiangran.cn/json?callback=handleResponse'</span><span class="token punctuation">;</span>
body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 3. 通过 script.src 请求 `http://www.laixiangran.cn/json?callback=handleResponse`，</span>
<span class="token comment">// 4. 后端能够识别这样的 URL 格式并处理该请求，然后返回 handleResponse({&quot;name&quot;: &quot;laixiangran&quot;}) 给浏览器</span>
<span class="token comment">// 5. 浏览器在接收到 handleResponse({&quot;name&quot;: &quot;laixiangran&quot;}) 之后立即执行 ，也就是执行 handleResponse 方法，获得后端返回的数据，这样就完成一次跨域请求了。</span>
</code></pre></div></li> <li><p><code>document.domain</code>：解决主域名相同，但子域名不同的情况，适用于 iframe 跨域；</p> <p>对于主域名相同，而子域名不同的情况，可以使用 document.domain 来跨域。这种方式非常适用于 iframe 跨域的情况。</p> <p>比如，从地址是 <code>http://www.laixiangran.cn/a.html</code>，访问 src 为 <code>http://laixiangran.cn/b.html</code> 的 iframe。此时子域不同，无法通过在页面中书写 js 代码来获取 iframe 中的内容。</p> <p>为了解决只需要将两个页面的 <code>document.domain</code> 设成相同的域名即可：</p> <div class="language-html extra-class"><pre class="language-html"><code>// a.html
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://laixiangran.cn/b.html<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>myIframe<span class="token punctuation">&quot;</span></span> <span class="token special-attr"><span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value javascript language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'laixiangran.cn'</span><span class="token punctuation">;</span> <span class="token comment">// 设置成主域</span>
    <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myIframe'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>contentWindow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

// b.html
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'laixiangran.cn'</span><span class="token punctuation">;</span> <span class="token comment">// document.domain 设置成与主页面相同</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><strong>注意</strong>：document.domain 的设置是有限制的，我们只能把 document.domain 设置成自身或更高一级的父域，且主域必须相同。例如：<code>a.b.laixiangran.cn</code> 中某个文档的 document.domain 可以设成 <code>a.b.laixiangran.cn</code>、<code>b.laixiangran.cn</code> 、<code>laixiangran.cn</code> 中的任意一个，但是不可以设成 <code>c.a.b.laixiangran.cn</code> ，因为这是当前域的子域，也不可以设成 <code>baidu.com</code>，因为主域已经不相同了。</p></li></ul></li> <li><p><code>socket</code> 和 <code>webSocket</code></p> <blockquote><p>在网络中的<strong>两个进程</strong>需要全双工相互通信 (双方可同时向对方发送消息)，需要用到<code>socket</code>，它能够提供<strong>端对端通信</strong>。</p> <p>程序员只需要在某个应用程序的一端 (eg: 客户端) 创建一个 <code>socket</code>,mkn 实例并且提供它所要连接一端 (eg: 服务端) 的IP地址和端口，而另外一端创建另一个 <code>socket</code> 并绑定本地端口进行 <code>listen</code>，然后客户端进行 <code>connect</code> 服务端，服务端接受连接之后双方建立了一个端对端的TCP连接，在该连接上就可以双向通讯了；</p> <p>一旦建立这个连接之后，通信双方就没有客户端服务端之分了，提供的就是端对端通信了。</p> <p>从本质上来说，socket并不是一个新的协议，它只是为了便于程序员进行网络编程而对tcp/ip协议族通信机制的一种封装。</p></blockquote> <blockquote><p><code>websocket</code> 是 <code>html5</code> 规范中的一个部分，它借鉴了 <code>socket</code> 思想，为web应用程序<strong>客户端和服务端</strong>之间提供了一种全双工通信机制；</p> <p>同时，它又是一种新的应用层协议，通常表示为：<code>ws://echo.websocket.org/?encoding=text HTTP/1.1</code>，除了协议名和http不同之外，它的表示地址就是传统的url地址；</p> <p>websocket具有以下几个方面的优势：</p> <ol><li>建立在 TCP 协议之上，服务器端的实现比较容易；</li> <li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器；</li> <li>数据格式比较轻量，性能开销小，通信高效；</li> <li>可以发送文本，也可以发送二进制数据；</li> <li>没有同源限制，客户端可以与任意服务器通信；</li> <li>协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL；</li></ol> <p>webSocket 与 HTTP/2服务器主动推送 的区别：</p> <p><strong>HTTP/2 引入了 Server Push ，它使服务器能够主动地将资源推送到客户端缓存。但是，它并不允许将数据推送到客户端应用程序本身</strong>。服务器推送只能由浏览器处理，不会在应用程序代码中弹出服务器数据，这意味着应用程序没有 API 来获取这些事件的通知；</p> <p>而 webSocket 是全双工通信，将数据推送到客户端本身；</p></blockquote></li> <li><p>TCP 和 UDP的区别</p> <ol><li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li> <li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付；</li> <li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道；</li> <li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li> <li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信；</li> <li>TCP首部开销20字节，UDP的首部开销小，只有8个字节；</li></ol></li> <li><p>前端安全问题：</p> <ol><li><p>XSS (跨站脚本攻击)：</p> <blockquote><p>html 或 js 脚本攻击，恶意攻击者向 <code>Web</code> 页面中插入恶意代码 (一般会在 a 标签或者 img 标签前插入一些 html 或 js 脚本)，当用户浏览网页时，这些恶意代码会被执行从而达到恶意攻击用户的目的；</p> <p>通常是通过 php 输出函数将 js 代码输出到 html 页面中，通过用户本地浏览器执行；</p> <p>预防 XSS 攻击：</p> <p>1、前端替换关键字，如替换<code>&lt;</code>为<code>&lt;</code> <code>&gt;</code> 为<code>&gt;</code>
2、后台替换。
3、任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。</p></blockquote></li> <li><p>CSRF (跨站请求伪造)：</p> <blockquote><p>CSRF也称为跨站请求伪造，其实就是对网站中的一些表单提交行为被黑客利用。例如在登陆 A 网站时存在 cookie 中的一些个人信息，而在退出登录之前，无意点击访问黑客的网站时，黑客网站收到用户的页面请求后，返回一些攻击性代码，并发出请求 (提交url) 求用户访问 A 网站，浏览器在接收到攻击性代码后，就根据黑客网站的请求，在用户不知情的情况下，携带用户的 cookie 信息，向 A 网站发出请求；而 A 网站并不知道请求是由黑客网站发起的，因此会根据恶意请求进行操作；</p> <p>预防 CSRF 攻击：</p> <ul><li><p>验证 HTTP Referer：</p> <p>在 HTTP 头部中有 Referer 字段，记录了 HTTP 请求的来源地址，但若黑客要对网站进行攻击，只能在自己的网站构造请求，因此当 A网站发现 Referer 不是规定网站的话，就会拒绝该请求；</p></li> <li><p>在请求地址中添加 token 并验证：</p> <p>CSRF 攻击在于黑客网站能完全伪造请求，在传统的 Session 请求中的所有用户验证信息，都是存在 cookie 中，因此黑客可以在不知道验证信息的情况下直接利用用户自己的 cookie 通过安全验证；因此可以在请求中放入黑客不能伪造的信息，且该信息不存在于 cookie 中；</p> <p>此时就可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务端建立拦截器来验证该 token，如果请求中没有 token 或者内容不正确，则拒绝请求；</p></li> <li><p>在 HTTP 投中自定义属性并进行验证：</p> <p>同样是使用 token 进行验证，但是把 token 放在 HTTP 请求头的自定义属性中；</p></li></ul></blockquote></li> <li><p>本地存储数据问题：一些个人信息不经加密就存储在本地或cookie中是极度不安全的，这会导致信息十分容易被盗用；</p></li> <li><p>HTTPS加密传输数据：</p> <blockquote><p>在浏览器对服务器访问或者请求的过程中，会经过很多的协议或者步骤，当其中某一步被拦截时，若没有被加密就极易被盗取；</p> <p>HTTPS中间人攻击：</p> <ol><li>服务器向客户端发送公钥，攻击者截获公钥，保留在自己手上，然后攻击者自己生成一个【伪造的】公钥，发给客户端。</li> <li>客户端收到伪造的公钥后，生成加密hash值发给服务器，攻击者获得加密hash值，用自己的私钥解密获得真秘钥，同时生成假的加密hash值，发给服务器；</li> <li>服务器用私钥解密获得假秘钥，服务器假秘钥加密传输信息；</li></ol> <p>此时如果使用了数字证书，将服务器的公钥放入数字证书中再发送给客户端。则浏览器可以通过自身内置的CA的公钥验证数字证书的真实性；</p></blockquote></li> <li><p>SQL注入</p> <blockquote><p>通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</p> <p>预防 SQL 注入的方法：</p> <ul><li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双&quot;-&quot;进行转换等。</li> <li>永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。</li> <li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li> <li>不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。</li></ul></blockquote></li></ol> <ul><li>CSRF 与 XSS区别：
<ul><li>XSS是向页面注入js去运行，然后在js函数体中做他想做的事情。
CSRF是利用网站漏洞，自动执行接口。用户需要登陆网站。</li> <li>XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。
CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。</li></ul></li></ul></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">12/27/2021, 7:52:43 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/interview/accumulates/react.html" class="prev">
        React
      </a></span> <span class="next"><a href="/interview/accumulates/webpack.html">
        Webpack
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b204aa68.js" defer></script><script src="/assets/js/3.11858a94.js" defer></script><script src="/assets/js/41.74542fa5.js" defer></script>
  </body>
</html>
