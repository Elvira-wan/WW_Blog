<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机网络 | WW&#39;s blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/assets/images/favicon.ico">
    <meta name="description" content="小万的学习日记">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.81d09c15.js" as="script"><link rel="preload" href="/assets/js/2.8398b084.js" as="script"><link rel="preload" href="/assets/js/3.521449cd.js" as="script"><link rel="prefetch" href="/assets/js/10.fec0f110.js"><link rel="prefetch" href="/assets/js/11.172fa010.js"><link rel="prefetch" href="/assets/js/12.614f5769.js"><link rel="prefetch" href="/assets/js/13.4d0b052d.js"><link rel="prefetch" href="/assets/js/14.a6aed245.js"><link rel="prefetch" href="/assets/js/15.bf0bd6bd.js"><link rel="prefetch" href="/assets/js/16.1e1ce84e.js"><link rel="prefetch" href="/assets/js/17.5372094f.js"><link rel="prefetch" href="/assets/js/18.f7f86485.js"><link rel="prefetch" href="/assets/js/19.1243f2f5.js"><link rel="prefetch" href="/assets/js/20.028a6a0e.js"><link rel="prefetch" href="/assets/js/21.edde94d8.js"><link rel="prefetch" href="/assets/js/22.3736cae0.js"><link rel="prefetch" href="/assets/js/23.cbb27253.js"><link rel="prefetch" href="/assets/js/24.94fc5442.js"><link rel="prefetch" href="/assets/js/25.440faeee.js"><link rel="prefetch" href="/assets/js/26.64fd4f6b.js"><link rel="prefetch" href="/assets/js/27.0eca257c.js"><link rel="prefetch" href="/assets/js/28.d8486f43.js"><link rel="prefetch" href="/assets/js/29.42771179.js"><link rel="prefetch" href="/assets/js/30.6200edbd.js"><link rel="prefetch" href="/assets/js/31.02ff8206.js"><link rel="prefetch" href="/assets/js/32.c40dca37.js"><link rel="prefetch" href="/assets/js/33.1355034e.js"><link rel="prefetch" href="/assets/js/34.f38a6a21.js"><link rel="prefetch" href="/assets/js/35.c540498a.js"><link rel="prefetch" href="/assets/js/36.3e7e22ca.js"><link rel="prefetch" href="/assets/js/37.b8683165.js"><link rel="prefetch" href="/assets/js/38.1c86bb9c.js"><link rel="prefetch" href="/assets/js/39.fba09886.js"><link rel="prefetch" href="/assets/js/4.3f57852d.js"><link rel="prefetch" href="/assets/js/40.4f536509.js"><link rel="prefetch" href="/assets/js/41.0508b3e6.js"><link rel="prefetch" href="/assets/js/42.c51c2847.js"><link rel="prefetch" href="/assets/js/43.93e5d495.js"><link rel="prefetch" href="/assets/js/44.45e204ef.js"><link rel="prefetch" href="/assets/js/45.1fe5400f.js"><link rel="prefetch" href="/assets/js/46.1adc7847.js"><link rel="prefetch" href="/assets/js/47.9f86d57c.js"><link rel="prefetch" href="/assets/js/5.a7ce3cbd.js"><link rel="prefetch" href="/assets/js/6.46d1b36f.js"><link rel="prefetch" href="/assets/js/7.e1e7eddb.js"><link rel="prefetch" href="/assets/js/8.8bee4585.js"><link rel="prefetch" href="/assets/js/9.56ff43bb.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">WW's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/accumulate/" class="nav-link router-link-active">
  前端基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="/internship/" class="nav-link">
  实习日记
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试总结
</a></div><div class="nav-item"><a href="https://github.com/Elvira-wan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  gitgub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/accumulate/" class="nav-link router-link-active">
  前端基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="/internship/" class="nav-link">
  实习日记
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试总结
</a></div><div class="nav-item"><a href="https://github.com/Elvira-wan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  gitgub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/accumulate/" aria-current="page" class="sidebar-link">前端基础</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端三剑客</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>前后端交互</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/accumulate/network/computerNetwork.html" aria-current="page" class="active sidebar-link">计算机网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/accumulate/network/computerNetwork.html#运输层" class="sidebar-link">运输层</a></li><li class="sidebar-sub-header"><a href="/accumulate/network/computerNetwork.html#应用层" class="sidebar-link">应用层</a></li></ul></li><li><a href="/accumulate/network/AJAX.html" class="sidebar-link">AJAX (Asychronous JavaScript And XML)</a></li><li><a href="/accumulate/network/cookie.html" class="sidebar-link">本地存储</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>主流框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>进阶部分</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="计算机网络"><a href="#计算机网络" class="header-anchor">#</a> 计算机网络</h1> <h2 id="运输层"><a href="#运输层" class="header-anchor">#</a> 运输层</h2> <blockquote><p>因特网的运输层为应用层提供了两种不同的运输协议，即<strong>面向连接的TCP</strong>和<strong>无连接的UDP</strong>，这两种协议就是运输层讨论的主要内容。</p> <p>运输层协议又称端到端协议，如何为<strong>运行在不同主机上的应用进程</strong>提供直接的通信服务是运输层的任务。</p></blockquote> <ul><li><h4 id="运输层端口号概念"><a href="#运输层端口号概念" class="header-anchor">#</a> 运输层端口号概念</h4> <ul><li><p>运行在计算机上的进程用PID (进程标识符) 来标志；</p></li> <li><p>计算机并不是统一的操作系统，不同的操作系统 <strong>使用不同格式的进程标识符</strong>；</p></li> <li><p>但为了使运行在不同操作系统之间的计算机应用进程之间能够进行网络通信，必须使用<strong>统一的方法对TCP/IP体系</strong>对应用进程进行标识；</p></li> <li><p>TCP/IP体系的运输层使用<strong>端口号</strong>来区分应用层的不同应用进程；</p> <ul><li><p>端口号使用16比特 (2^16) 表示，取值范围 0~65535;</p> <ul><li><strong>熟知端口号</strong>：0~1023，IANA把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，例如：<strong>FTP使用 21/20，HTTP使用 80，DNS使用 53</strong>。</li> <li><strong>登记端口号</strong>：1024~49151，为没有熟知端口号的应用程序使用。</li> <li><strong>短暂端口号</strong>：49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号，通信结束后，这个端口号可供其他客户进程以后使用。</li></ul></li> <li><p><strong>端口号只具有本地意义</strong>，即端口号只是为了标识本计算机应用层的各个进程，在因特网中，<strong>不同计算机中的相同端口号是没有联系的</strong>。</p></li></ul></li></ul></li> <li><h4 id="运输层复用和分用概念"><a href="#运输层复用和分用概念" class="header-anchor">#</a> 运输层复用和分用概念</h4> <p><img src="/assets/img/image-20210119221134373.7955ff0d.png" alt="image-20210119221134373"></p> <ul><li><p><strong>TCP/IP体系的应用层常用协议所使用的运输层熟知端口号</strong></p> <p><img src="/assets/img/image-20210119221606516.f49bbace.png" alt="image-20210119221606516"></p></li> <li><p><strong>域名服务器 (DNS服务器）</strong></p> <ul><li><p>网络通讯大部分是基于TCP/IP的，而TCP/IP是基于IP地址的，所以计算机在网络上进行通讯时只能识别如“202.96.134.133”之类的IP地址，而不能认识域名。我们无法记住10个以上IP地址的网站，所以我们访问网站时，更多的是在浏览器地址栏中输入域名，就能看到所需要的页面，这是因为有一个叫“DNS服务器”的计算机自动把我们的域名“翻译”成了相应的IP地址，然后调出IP地址所对应的网页。</p></li> <li><p>DNS是应用层协议，事实上他是为其他应用层协议工作的，包括不限于HTTP和SMTP以及FTP，<strong>用于将用户提供的主机名解析为ip地址</strong>。</p> <p><strong>DNS获取具体过程如下：</strong></p> <ol><li>用户主机上运行着DNS的客户端；</li> <li>浏览器将接收到的url中抽取出域名字段，就是访问的主机名，比如<code>http://www.baidu.com/</code>, 并将这个主机名传送给DNS应用的客户端；</li> <li>DNS客户机端向DNS服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式DNS集群的工作）；</li> <li>该DNS客户机最终会收到一份回答报文，其中包含有该主机名对应的IP地</li> <li>一旦该浏览器收到来自DNS的IP地址，就可以向该IP地址定位的HTTP服务器发起TCP连接；</li></ol></li></ul></li> <li><p><strong>用户端获取页面的流程</strong></p> <p><img src="/assets/img/image-20210119224219378.8917727a.png" alt="image-20210119224219378"></p> <p><img src="/assets/img/image-20210119224658006.c123320d.png" alt="image-20210119224658006"></p> <ol><li><p>由用户端在浏览器地址栏中输入url地址；</p></li> <li><p>浏览器使用<strong>UDP协议</strong>向DNS服务器发送DNS查询请求；</p></li> <li><p>DNS服务器依照浏览器发送的url获取页面的IP地址；</p></li> <li><p>DNS服务器响应用户端，将页面IP地址发回给用户端；</p></li> <li><p>用户端收到页面IP地址，并使用<strong>TCP/IP协议</strong>发送HTTP请求给Web服务器；</p></li> <li><p>Web服务器收到用户端的HTTP请求，并以HTTP响应将页面内容发送给用户端。</p></li></ol></li></ul></li> <li><h4 id="udp和tcp对比"><a href="#udp和tcp对比" class="header-anchor">#</a> UDP和TCP对比</h4> <p><img src="/assets/img/image-20210119225231541.c92ea000.png" alt="image-20210119225231541"></p> <p><img src="/assets/img/image-20210119230850583.c26f1a61.png" alt="image-20210119230850583"></p> <ul><li><p><strong>面向报文传输和面向字节流传输</strong></p> <ol><li><p><strong>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文</strong>。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会使IP太小。</p> <p>UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。</p></li> <li><p><strong>面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流</strong>。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</p></li></ol></li> <li><p><strong>可靠交付和不可靠交付</strong></p> <ul><li><p>UDP是不可靠交付，若有误码，仅仅丢弃，其他什么也不做，适用于IP电话、视频会议等实时应用；</p></li> <li><p>TCP/IP是可靠交付，不会出现传输差错，适用于要求可靠传输的应用，例如文件传输；</p></li></ul></li></ul></li> <li><h4 id="tcp的流量控制"><a href="#tcp的流量控制" class="header-anchor">#</a> TCP的流量控制</h4> <ul><li>流量控制就是让发送方的发送速率不要太快，让接收方来不及接受，以避免导致数据的丢失。</li> <li>利用<strong>滑动窗口</strong>机制可以方便的在TCP连接上实现对发送方的流量控制。
<ul><li>TCP接收方<strong>利用自己的接受窗口的大小</strong>来<strong>限制发送方的发送窗口大小</strong>；</li> <li>TCP发送方收到接收方的<strong>零窗口通知</strong>后，应<strong>启动持续计时器</strong>，持续计时器<strong>超时后</strong>，向接收方<strong>发送零窗口探测报文</strong>；</li></ul></li></ul> <p><img src="/assets/img/image-20210119233306493.52122c4c.png" alt="image-20210119233306493"></p> <div class="language-text extra-class"><pre class="language-text"><code>此时字节数据并未发送完毕，B主机接收缓存后又有了一些存储空间，此时它将自身接收窗口调整为300，并通告A主机，等待A主机发来数据。

如果此时该通告丢失！

A主机会一直等待B主机发送的非零窗口通知；
B主机也在一直等待A主机发送来的字节数据；
这种互相等待使得两个主机形成一种死锁局面，并一直持续。

此时采取持续计时器措施，如下：
</code></pre></div><p><img src="/assets/img/image-20210119233556786.4d9051ca.png" alt="image-20210119233556786"></p></li> <li><h4 id="tcp的拥塞控制"><a href="#tcp的拥塞控制" class="header-anchor">#</a> TCP的拥塞控制</h4> <ul><li><p>某段时间，若<strong>对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏</strong>，这种情况就叫<strong>拥塞</strong>。</p> <p>注：在计算机网络中的链路容量 (带宽)、交换结点中的缓存和处理机等，都是网络资源。</p></li> <li><p>出现拥塞而<strong>不及时控制</strong>，整个网络的<strong>吞吐量将随着负荷的增大而下降</strong>。</p> <p><img src="/assets/img/image-20210120000251293.437a1bc8.png" alt="image-20210120000251293"></p></li> <li><p><strong>四种避免拥塞的方法</strong></p> <ul><li><p><strong><u>慢开始算法</u></strong></p> <ul><li><p>当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况；</p> <p>因此，较好的办法是先探测下，即由小到大逐渐增大发送窗口，也就说，由小到大逐渐增大拥塞窗口数值；</p> <p>通常在刚刚开始发送报文段时，先把拥塞窗口cwnd设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口cwnd，可以使分组注入到网络的速率更加合理。</p></li> <li><p><strong>每经过一个传输轮次，拥塞窗口wcnd就加倍</strong> (拥塞窗口的大小等于此时发送的报文数，则拥塞窗口加倍就代表着此时发送报文的数量加倍)；</p></li> <li><p><img src="/assets/img/image-20210120110442322.37279d40.png" alt="image-20210120110442322"></p></li></ul></li> <li><p><strong><u>拥塞避免算法</u></strong></p> <ul><li>让拥塞窗口cwnd缓慢地增大，<strong>即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1</strong>；</li> <li>当有报文数据段丢失，发送方未收到接收方发出的确认，重传计时器超时时，则判断网络可能出现拥堵；
<ol><li>此时将ssthresh的值更新为<strong>发生拥塞时拥塞窗口cwnd值的一半</strong>；</li> <li><strong>拥塞窗口cwnd值变为1</strong>，重新执行慢开始算法；</li></ol></li></ul></li> <li><p><strong><u>快重传算法</u></strong></p> <ul><li><p>但其实有时个别报文段会在网络中丢失，但实际网络并未发生拥塞，错误的将拥塞窗口cwnd变为1，启动慢开始算法，<strong>极大的降低了传输效率</strong>；</p></li> <li><p>此时启用快重传算法，让发送方可以更早的知道个别报文段的丢失，不必等到超时重传计时器超时再重传；</p> <ul><li><p>要求<strong>接收方</strong>不要等待自己收到发送数据时才进行捎带确认，而是<strong>立即发送确认</strong>；</p></li> <li><p>即使<strong>接受方</strong>收到了失序报文段也要立即发出对已收到报文段的<strong>重复确认</strong>；</p></li> <li><p><strong>发送方</strong>一旦<strong>收到了3个连续的重复确认</strong> (重复确认是从接收方收到失序报文段开始的)，就将相应的报文段<strong>立即重传</strong>，而不是等该报文端的超时重传计时器超时再重传。</p> <p><img src="/assets/img/image-20210120131759226.744ff880.png" alt="image-20210120131759226"></p></li></ul></li></ul></li> <li><p><strong><u>快恢复算法</u></strong></p> <ul><li><p>发送方一旦收到3个重复确认，就知道只是丢失了个别报文段，于是不启动慢开始算法，而执行快恢复算法；</p> <ul><li><p>发送方将<strong>慢开始门限ssthresh值和拥塞窗口cwnd值都调整为当前窗口的一半，开始执行拥塞避免算法</strong>；</p></li> <li><p>也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd的值设置为，<strong>新的ssthresh+3</strong></p> <ul><li>以为发送方收到3个重复确认，就表明有3个数据报文已经离开网络；</li> <li>这3个报文段不再消耗网络资源而是停留在接收方的接受缓存中；</li> <li>因此现在网络中不是堆积了报文段而是减少了3个报文段，所以可以把拥塞窗口增大些；</li></ul> <p><img src="/assets/img/image-20210120133400179.20a8e132.png" alt="image-20210120133400179"></p></li></ul></li></ul></li></ul> <p>以上四种方法的<strong>基本原理</strong>：</p> <p><img src="/assets/img/image-20210120000640174.ecddd8e8.png" alt="image-20210120000640174"></p></li></ul></li> <li><h4 id="tcp超时重传时间选择"><a href="#tcp超时重传时间选择" class="header-anchor">#</a> TCP超时重传时间选择</h4> <ul><li><p>重传时间选择较短：引起不必要的重传，使网络负荷较大。</p> <p><img src="/assets/img/image-20210120152024827.ccac3446.png" alt="image-20210120152024827"></p></li> <li><p>重传时间选择较长：会使下一个报文数据没办法及时发送，空闲时间增大，降低传输效率。</p> <p><img src="/assets/img/image-20210120152156245.322a5fee.png" alt="image-20210120152156245"></p></li> <li><p><strong>较为合适的超时重传时间应该略大于往返时间</strong></p> <p><img src="/assets/img/image-20210120154043927.d9c1c804.png" alt="image-20210120154043927"></p></li></ul> <p><img src="/assets/img/image-20210120153902028.0c669481.png" alt="image-20210120153902028"></p></li> <li><h4 id="tcp可靠传输的实现"><a href="#tcp可靠传输的实现" class="header-anchor">#</a> TCP可靠传输的实现</h4> <ul><li><p>TCP基于<strong>以字节为单位的滑动窗口</strong>来实现可靠传输；</p> <ul><li>发送方在未收到接收方确认时，可将发送窗口内还未发送的数据发送出去</li> <li>接收方只接收序号落入发送窗口内的数据</li></ul></li> <li><p>虽然发送方的发送窗口是根据接收方的接收窗口设置的，<strong>但同一时刻两个窗口大小并不总是一样大</strong>；</p> <ul><li>网络传递窗口值需要经历一定的时间滞后，且时间不确定</li> <li>发送方还可能根据当时网络的拥塞情况改变自己发送窗口的大小</li></ul></li> <li><p>对于<strong>不按序到达的数据该如何处理</strong> (丢弃 或者 临时存放在接收窗口中等待字节流中所缺少的字节收到后，再按序交付给上层应用程序)，TCP无明确规定；</p></li> <li><p>TCP要求接收方必须有<strong>累计确认</strong>和<strong>捎带确认</strong>机制，以此减小传输开销；</p> <ul><li>接收方不应过分推迟发送确认，否则会导致不必要的超时重传</li> <li>捎带确认不经常发生，因为大多数应用程序很少同时在两个方向上发送数据</li></ul></li> <li><p><strong>TCP的通信是全双工通信</strong>，通信中的每一方都在发送和接受报文段；</p></li></ul></li> <li><h4 id="tcp建立连接"><a href="#tcp建立连接" class="header-anchor">#</a> TCP建立连接</h4> <ul><li><p><strong>三报文握手</strong>建立连接</p> <p><img src="/assets/img/image-20210120203411189.1fdb0199.png" alt="image-20210120203411189"></p> <p><strong>第一次</strong></p> <p>第一次握手：建立连接时，客户端发送<a href="https://baike.baidu.com/item/syn" target="_blank" rel="noopener noreferrer">syn<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>包（seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p> <p><strong>第二次</strong></p> <p>第二次握手：服务器收到<a href="https://baike.baidu.com/item/syn" target="_blank" rel="noopener noreferrer">syn<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>包，必须确认客户的SYN（<a href="https://baike.baidu.com/item/ack" target="_blank" rel="noopener noreferrer">ack<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。</p> <p><strong>第三次</strong></p> <p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(<a href="https://baike.baidu.com/item/ack" target="_blank" rel="noopener noreferrer">ack<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>=k+1），此包发送完毕，客户端和服务器进入<a href="https://baike.baidu.com/item/ESTABLISHED" target="_blank" rel="noopener noreferrer">ESTABLISHED<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>（TCP连接成功）状态，完成三次握手。</p> <p>完成三次握手，客户端与服务器开始传送数据。</p> <blockquote><p>注：</p> <p>1）TCP的标准规定，SYN=1的报文段不能携带数据，但要消耗一个序号。</p> <p>2）TCP的标准规定，普通的确认报文如果不携带数据则不消耗序号。</p></blockquote></li></ul></li> <li><h4 id="tcp的连接释放"><a href="#tcp的连接释放" class="header-anchor">#</a> TCP的连接释放</h4> <ul><li><p><strong>四挥手报文</strong>释放连接</p> <p><img src="/assets/img/image-20210120203944410.022b8ff5.png" alt="image-20210120203944410"></p></li></ul></li> <li><h4 id="tcp报文段首部格式"><a href="#tcp报文段首部格式" class="header-anchor">#</a> TCP报文段首部格式</h4> <p><img src="/assets/img/image-20210120210216181.5d02c188.png" alt="image-20210120210216181"></p> <h2 id="应用层"><a href="#应用层" class="header-anchor">#</a> 应用层</h2> <blockquote><p>应用层是计算机网络体系结构的<strong>最顶层</strong>，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分。</p> <p>解决通过应用进程的交互来实现特定网络应用的问题</p></blockquote></li></ul> <p>​	<img src="/assets/img/image-20210127152925666.29360292.png" alt="image-20210127152925666"></p> <ul><li><h4 id="客户-服务器方式-c-s方式-和-对等方式-p2p方式"><a href="#客户-服务器方式-c-s方式-和-对等方式-p2p方式" class="header-anchor">#</a> 客户/服务器方式 (C/S方式) 和 对等方式 (P2P方式)</h4> <ul><li><p>网络应用程序运行在处于网络边缘的不同的端系统上，通过彼此间的通信来共同完成某项任务。</p></li> <li><p>开发一种新的网络应用首先需要考虑的问题就是<strong>网络应用程序在各种端系统上的组织方式和它们之间的关系</strong>，目前流行的主要有以下两种：</p> <ul><li><p><strong>客户/服务器</strong> (Client/Server, C/S) 方式</p> <ul><li><p>客户和服务器是指通信中所涉及的两个应用进程；</p></li> <li><p>客户/服务器方式所描述的是进程之间服务和被服务的关系；</p></li> <li><p><strong>客户是服务请求方，服务器是服务提供方</strong>；</p></li> <li><p><strong>服务器总是处于运行状态</strong>，并等待客户的请求服务。<strong>服务器具有固定的端口号 (例如HTTP服务器的默认端口号为80)，而运行服务器的主机也具有固定的IP地址</strong>；</p> <p><img src="/assets/img/image-20210127155426940.ce16ab90.png" alt="image-20210127155426940"></p></li> <li><p>C/S方式是因特网上传统的、同时也是最成熟的方式，很多我们熟悉的网络应用采用的都是C/S方式；包括<strong>万维网WWW、电子邮件、文件传输FTP等</strong>；</p></li> <li><p>基于C/S方式的应用服务通常是<strong>服务集中形</strong>的，即应用服务集中在网络中比客户计算机少得多的服务计算器上；</p> <ul><li><p>由于一台服务器计算器要为多个客户机提供服务，在C/S应用中，<strong>常会出现服务器计算机更不上众多客户机请求的情况</strong>。</p></li> <li><p>为此，在C/S应用中，常用<strong>计算机集群</strong>构建一个强大的<strong>虚拟服务器</strong>。</p></li></ul></li></ul></li> <li><p><strong>对等方式</strong> (Peer-to-Peer, P2P) 方式</p> <ul><li><p>在P2P方式中，<strong>没有固定的服务请求者和服务提供者</strong>，分布在网络边缘各端系统中的应用程序是对等的，被称为<strong>对等方</strong>。<strong>对等方之间直接通信</strong>，每个对等方即是服务请求者，又是服务提供者。</p></li> <li><p>目前，在 因特网上流行的P2P应用主要包括<strong>P2P文件共享、即时通信、P2P流媒体、分布式储存等</strong>；</p></li> <li><p>基于P2P的应用是<strong>服务分散型</strong>的，因为服务不是集中在少数几个服务型计算机中，而是分散在大量对等计算机中，这些计算机并不为服务供应商所有，而是为个人控制的桌面计算机和笔记本电脑，他们通常位于住宅、校园和办公室中。</p> <p><img src="/assets/img/image-20210127163129400.21ea6ee5.png" alt="image-20210127163129400"></p></li> <li><p>P2P方式的最突出特性之一就是它的<strong>可延展性</strong>。因为系统每增加一个对等方，不仅增加的是服务的请求者，同时也增加了服务的提供者，<strong>系统性能不会因为规模的增大而降低</strong>。</p></li> <li><p>P2P方式<strong>具有成本上的优势</strong>，因为它通常不需要庞大的服务器设施和服务器带宽；</p></li></ul></li> <li><p>两者对比</p> <p><img src="/assets/img/image-20210127163928886.b10b9908.png" alt="image-20210127163928886"></p></li></ul></li> <li><h4 id="动态主机配置协议dhcp"><a href="#动态主机配置协议dhcp" class="header-anchor">#</a> 动态主机配置协议DHCP</h4> <ul><li><p>两台连接到互联网上的电脑相互之间通信，必须有各自的IP地址，由于IP地址资源有限，宽带接入运营商不能做到给每个报装宽带的用户都能分配一个固定的IP地址，<strong>所以要采用DHCP方式对上网的用户进行临时的地址分配</strong>。</p> <p>也就是你的电脑连上网，DHCP服务器才从地址池里临时分配一个IP地址给你，每次上网分配的IP地址可能会不一样，这跟当时IP地址资源有关。</p> <p>当下线的时候，DHCP服务器可能就会把这个地址分配给之后上线的其他电脑。这样就可以有效节约IP地址，既保证了网络通信，又提高IP地址的使用率。</p> <p><img src="/assets/img/image-20210127172041922.3407eeea.png" alt="image-20210127172041922"></p></li> <li><p><strong>DHCP工作过程</strong></p> <ol><li>DHCP DISCOVERY：请求IP租约</li> <li>DHCP OFFER：提供IP租约</li> <li>DHCP REQUEST：选择IP租约</li> <li>DHCP ACK：确认IP租约</li></ol> <p><img src="/assets/img/image-20210127191622138.cd4ab245.png" alt="image-20210127191622138"></p> <p><img src="/assets/img/image-20210127192741805.907cfd43.png" alt="image-20210127192741805"></p></li></ul></li> <li><h4 id="域名系统dns"><a href="#域名系统dns" class="header-anchor">#</a> 域名系统DNS</h4> <p><img src="/assets/img/image-20210127195223029.41785fde.png" alt="image-20210127195223029"></p> <p><img src="/assets/img/image-20210127195236896.6bd3844a.png" alt="image-20210127195236896"></p> <p><img src="/assets/img/image-20210127195335517.db69ecb4.png" alt="image-20210127195335517"></p> <p><img src="/assets/img/image-20210127200217902.ec8547f9.png" alt="image-20210127200217902"></p> <ul><li><p><strong>域名解析过程</strong></p> <ul><li><p><strong>递归查询</strong>：<strong>主机向本地域名服务器的查询一般都是采用递归查询</strong>。</p> <p>所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文（<strong>即替该主机继续查询</strong>），而不是让该主机自己进行下一步的查询。</p> <p>因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p></li> <li><p><strong>迭代查询</strong>：<strong>本地域名服务器向根域名服务器的查询通常是采用迭代查询</strong>。</p> <p>迭代查询的特点是这样的：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器，“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询（<strong>而不是替本地域名服务器进行后续的查询</strong>）。</p> <p>根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应该向哪一个权限域名服务器进行查询。最后，知道了所要解析的域名的IP地址，然后把这个结果返回给发起查询的主机。</p> <p>当然，本地域名服务器也可以采用递归查询，这取决于最初的请求报文的设置是要求使用哪一种查询方式。</p></li></ul></li></ul> <p><img src="/assets/img/image-20210127200456148.eae8896f.png" alt="image-20210127200456148"></p> <ul><li><p><strong>高速缓存</strong></p> <p><img src="/assets/img/image-20210127201827086.6b12815e.png" alt="image-20210127201827086"></p> <p><img src="/assets/img/image-20210127201846015.6c317779.png" alt="image-20210127201846015"></p></li></ul></li> <li><h4 id="文件传送协议ftp"><a href="#文件传送协议ftp" class="header-anchor">#</a> 文件传送协议FTP</h4> <ul><li><p>将某台计算机中的文件通过网络传送到可能相距很远的另一台计算机中，是一项基本的网络应用，即文件传送；</p></li> <li><p><strong>文件传送协议FTP</strong>是因特网上使用最广泛的文件传送协议；</p> <ul><li>FTP<strong>提供交互式访问</strong>，允许客户<strong>指明文件的类型与格式</strong>，并允许<strong>文件具有存取权限</strong> (如访问文件的用户必须经过授权，并输入有效的口令)；</li> <li>FTP屏蔽了各计算机系统的细节，因而合适于在异构网络中任意计算机之间传送文件；</li></ul></li> <li><p><strong>FTP基本工作原理</strong></p> <p><img src="/assets/img/image-20210127221420472.cec19823.png" alt="image-20210127221420472"></p> <p><img src="/assets/img/image-20210127221629129.077c15cf.png" alt="image-20210127221629129"></p> <p><img src="/assets/img/image-20210127221732358.dbae0af5.png" alt="image-20210127221732358"></p> <p><img src="/assets/img/image-20210127221958502.97b6485b.png" alt="image-20210127221958502"></p></li></ul></li> <li><h4 id="电子邮件"><a href="#电子邮件" class="header-anchor">#</a> 电子邮件</h4> <p><img src="/assets/img/image-20210127222926171.9684655c.png" alt="image-20210127222926171"></p> <ul><li><p>电子邮件采用<strong>客户/服务器方式</strong></p></li> <li><p>电子邮件系统的三个主要组成构件：<strong>用户代理、邮件服务器</strong>，以及<strong>电子邮件所需的协议</strong>；</p> <ul><li><p><strong>用户代理</strong>：是用户与电子邮件系统的接口，又称为<strong>电子邮件客户端软件</strong>；</p></li> <li><p><strong>邮件服务器</strong>是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其<strong>功能是发送和接收邮件</strong>，同时还要负责维护用户的邮箱；</p></li> <li><p><strong>协议</strong>包括邮件<strong>发送协议</strong> (例如SMTP) 和 邮件<strong>读取协议</strong> (例如POP3，IMAP)</p> <p><img src="/assets/img/image-20210128000010930.58aac3d7.png" alt="image-20210128000010930"></p> <p><img src="/assets/img/image-20210128000346137.28f790a5.png" alt="image-20210128000346137"></p></li></ul></li> <li><p><strong>简单邮件传送协议SMTP</strong>的基本工作原理</p></li></ul> <p><img src="/assets/img/image-20210128003842344.1ebcd502.png" alt="image-20210128003842344"></p> <p><img src="/assets/img/image-20210128004640984.8a5f58dc.png" alt="image-20210128004640984"></p> <p><img src="/assets/img/image-20210128004941091.11311b1d.png" alt="image-20210128004941091"></p> <p><img src="/assets/img/image-20210128005008171.4a26135d.png" alt="image-20210128005008171"></p> <ul><li><p><strong>邮件读取协议</strong></p> <ul><li><p><strong>邮局协议POP</strong>，POP3是其第三个版本，是因特网正式标准；</p> <p>非常简单、功能有限的邮件读取协议；用户只能以<strong>下载并删除</strong>或<strong>下载并保留</strong>的方式从邮件服务器下载邮件到用户方计算机；<strong>不允许用户在邮件服务器上管理自己的邮件</strong> (例如创建文件夹，对邮件进行分类管理等)；</p></li> <li><p><strong>因特网邮件访问协议IMAP</strong>，IMAP4是其第四个版本，目前还只是英特网建议标准；</p> <p>功能比POP3强大的邮件读取协议；<strong>用户在自己的计算机上可以操控邮件服务器中的邮箱</strong>，就像在本地操控一样，因此是IMAP是一个联机协议；</p></li> <li><p>POP3和IMAP协议都采用<strong>基于TCP连接的客户/服务器方式</strong>；<strong>POP3使用</strong>熟知的端口<strong>110</strong>，<strong>IMAP4使用</strong>熟知的端口<strong>143</strong>；</p></li> <li></li></ul> <p><img src="/assets/img/image-20210128010527694.30d981c0.png" alt="image-20210128010527694"></p></li> <li><p><strong>基于万维网的电子邮件</strong></p> <p><img src="/assets/img/image-20210128010828547.b4b75510.png" alt="image-20210128010828547"></p></li></ul></li></ul></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">12/21/2021, 2:51:14 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/accumulate/base/JS_base/regExp.html" class="prev">
        正则表达式
      </a></span> <span class="next"><a href="/accumulate/network/AJAX.html">
        AJAX (Asychronous JavaScript And XML)
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.81d09c15.js" defer></script><script src="/assets/js/2.8398b084.js" defer></script><script src="/assets/js/3.521449cd.js" defer></script>
  </body>
</html>
