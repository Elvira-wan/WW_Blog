# 前端性能优化



## JS性能优化

- JS 单线程

  > 浏览器是多线程的，它们在内核制控下相互配合以保持同步。一个浏览器至少实现三个常驻线程：JavaScript引擎线程，GUI渲染线程，浏览器事件触发线程（UI线程）。

  - javascript引擎是基于事件驱动单线程执行的。JS引擎一直等待着event loop中任务的到来，然后加以处理（只有当前函数执行栈执行完毕，才会去任务队列中取任务执行）。**浏览器无论什么时候都只有一个JS线程在运行JS程序**。
  - UI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。但是 **GUI渲染线程与JS引擎是互斥的**，当JS引擎执行时GUI线程会被挂起，JS对页面的操作即GUI的更新也会被保存在一个队列中，等到JS引擎空闲时才有机会被执行。这就是**JS阻塞页面加载**。
  - 事件触发线程，当一个事件被触发时该线程会把事件添加到任务队列的队尾，等待JS引擎的处理。这些事件可以来自JavaScript引擎当前执行的代码块调用setTimeout/ajax添加一个任务,也可以来自浏览器其他线程如鼠标点击添加的任务。但由于JS的单线程关系，所有这些事件都得排队等待JS引擎处理。

  **注意：**javascript要等主线程空了才会去查看子线程有没有回调内容。异步的任务执行的顺序是不固定的，主要看返回的速度；

  

- DOM的重绘和重排：

  > 重排：若渲染树的一部分更新且尺寸变化，就会发生重排；
  >
  > 重绘：部分节点需要更新，但不改变其他集合形状，如改变某个元素的颜色，就会发生重绘；
  >
  > 回流：浏览器流式布局，DOM节点树形结构，一个节点改变，整个DOM重新计算，引发回流；

  回流触发条件：

  - 首次渲染；
  - 改变DOM节点；
  - DOM节点 `style` 样式的改变，元素位置，元素大小；
  - 页面大小改变，`resize()` 事件；
  - 激活一些伪类；

  **注意**：回流一定重绘，但重绘不一定回流；

  为了提高效率减少重绘，可以进行以下操作：

  - DOM操作不放在循环中；

  - `style` 样式写做 `class`，改变 `class` 即可，只重绘一次；

  - 动画 HTML 的 `position` 尽量设成 `fixed` or `absolute`；

  - 不使用 `table`；

    

- 谈一下对防抖节流的理解

  > 概括来说就是当某事件被触发频率过高，若出路不当或放任不管，很容易引起浏览器卡死；
  >
  > 例如，简体浏览器滚动事件，返回当前滚条与顶部的距离，在运行的时候会发现，该事件被触发的频率太高了，可能随意的一次滑动鼠标滚轮就可以执行 8- 9 次，而实际上，我们并不需要如此高频的反馈，这样会浪费浏览器的性能，为了优化这种场景，就有了防抖节流；

  防抖：

  > 思路：在第一次触发时间时，并不立即执行函数，而是给出一个期限值 (假设为 200ms):
  >
  > - 若 200ms 内没有再次触发滚动事件，就执行函数；
  > - 若 200ms 内再次触发，则当前计时取消，重新开始计时；

  此时效果为若短时间内大量触发同一事件，但依旧只会执行一次函数；

  ````js
  // fn: 需要防抖的函数
  // delay: 防抖期限值
  function debounce(fn, delay) {
      let timer = null;
      return function() {
          // 若该计时器已存在，则清除前一个，重启计时器，则计时也重置
          if (timer) {
          	clearTimeout(timer);   
          }
          timer = setTimeout(fn, delay);
      }
  }
  
  // 调用
  function showTop  () {
      var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
  　　console.log('滚动条位置：' + scrollTop);
  }
  window.onscroll = debounce(showTop,200);
  ````

  节流：

  >根据防抖可知，若此时用户不断地拖动滚动条，就永远无法触发事件，输出当前离顶部的距离；
  >
  >但此时需求为，即使用户不断地拖动滚动条，也能在某个时间间隔之后给出反馈，就需要用到防抖的知识；
  >
  >思路：设计一个定期开放的控制阀门，在函数执行一次后另阀门在某时间段内暂时失效，过了该时间段再重新激活；

  ````js
  function throttle(fn,delay){
      let valid = true
      return function() {
         if(!valid){
             //休息时间 暂不接客
             return false 
         }
         // 工作时间，执行函数并且在间隔期内把状态位设为无效
          valid = false
          setTimeout(() => {
              fn()
              // 执行完毕后，打开该控制阀门
              valid = true;
          }, delay)
      }
  }
  
  function showTop  () {
      var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
  　　console.log('滚动条位置：' + scrollTop);
  }
  window.onscroll = throttle(showTop,1000);
  ````

  节流函数并不止上面这种实现方案：

  - 也可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定；

  - 也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活；

    

- 前端加载较慢时，需要从哪些方面排查问题

  1. 检查 css，js，图片文件大小，可考虑压缩文件；

  2. 检查 css，js，图片文件数量，考虑合并资源，减少网络请求数量；

  3. 检查 js 文件位置，考虑将外部资源文件或者不是首屏加载的文件放在最后加载；

  4. 检查文档元素操作，避免平凡的重绘或重绘页面 (display: none 的使用)；

  5. 可以使用 cdn来缓存资源文件；

  6. 检查 cookie 值是否过大，考虑改用 webStorage；

  7. 检查后端接口损耗时，考虑将一些接口异步加载；

     

- 非核心代码异步加载

  - `script` 直接加载：

    > 正常情况下，当浏览器在解析HTML源文件时如果遇到外部的script，那么解析过程会暂停，并发送请求来下载script文件，只有script完全下载并执行后才会继续执行DOM解析。
    >
    > 当一个页面有很多的外链的脚本。放在head中，那么加载脚本的时候就会阻塞页面的渲染，出现空白的现象。
    >
    > 在简单的开发环境中可能调整一下js的位置就能解决问题。但是在越来越复杂的开发环境下，如果想调整js脚本的位置可能就要花费大量的时间。所以为了让这种成本降低。可以使用defer属性。

  - 标签中加 `defer` 关键字：

    >一个script加了defer属性，即使放在head里面，它也会在html页面解析完毕之后再去执行，也就是类似于把这个script放在了页面底部。

  - 标签中加 `async` 关键字：

    >对于async，这个是html5中新增的属性，它的作用是能够异步的加载和执行脚本，不因为加载脚本而阻塞页面的加载。一旦加载到就会立刻执行。

  

  `defer` 和 `async` 的区别：

  - 两者的相同点：

    1. 加载文件时不阻塞页面渲染。
    2. 对于inline的script无效。
    3. 使用这两个属性的脚本中不能调用document.write方法。
    4. 有脚本的onload的事件回调。

  - 不同点：

    1. html4.0中定义了defer，html5.0中定义了async。

    2. async属性的脚本会在下载结束后立刻执行，同时会在window的load事件之前执行，所以就会出现顺序被打乱的情况；

       defer属性的脚本是在页面解析完成后，按照顺序执行，同时会在document的DOMContentLoaded之前执行。

    总体来说，defer和async的主要不同就是defer会保证脚本的顺序，async不保证顺序；

  

## 网络请求优化

- 网页内容

  >**减少http请求次数**
  >
  >1. 打包压缩文件，将多个样式表文件捆绑成一个文件，以此来减少文件的下载次数，比如React中使用，`npm run bulid` 形成一个 `bundle.js`；
  >2. 雪碧图；
  >3. 通过编码字符串 Base64 将图片内嵌到网页文本中；
  >
  >**减少DNS查询次数**
  >
  >DNS查询消耗响应事件，如果网页内容来自不同 `domain`，那么客户端首次解析不同的 `domain` 也要消耗一定时间，因为DNS查询结果缓存在本地系统和浏览器中一段时间，因此一般是对首次访问响应速度有影响；
  >
  >**避免页面跳转**
  >
  >当页面收到 3 开头的状态码回复重定向时，需要再次发送请求；
  >
  >**缓存Ajax**
  >
  >帮助异步下载网页，但尽量遵循以下原则提高ajax响应:
  >
  >- 添加 Expires 或 Cache-Control 报文头使回复可以被客户端缓存
  >- 压缩回复内容
  >- 减少dns查询
  >- 精简javaScript代码
  >- 避免跳转
  >- 配置Etag
  >
  >**延迟加载**
  >
  >初次只获取网页最初加载需要的最小内容集，剩下的内容推到延迟加载的集合中；
  >
  >**提前加载**
  >
  >与延迟加载相反，提前加载接下来网页中访问的内容，类似https中的服务器主动推送；
  >
  >**减少DOM元素的数量**
  >
  >`document.getElementsByTagName('*').length` 可获取网页中DOM元素的数量；
  >
  >**根据域名划分内容**
  >
  >浏览器一般争对同一个域的下载连接数有所限制，按照域名划分下载内容可以使浏览器增大并行下载连接，但域名注意控制在2-4个之间，否则影响dns查询效率；
  >
  >**避免404**
  >
  >客户端发送请求，但结果为404，浪费了请求来回时间，且当网页中需要加载一个外部脚本，结果返回404不仅阻塞其他脚本下载，下载回来的内容还会被客户端当成JavaScript解析；

- 服务器

  >**使用CDN**
  >
  >减少网页内容下载时间，提高下载速度还可以CDN(内容分发网络)来提升，CDN听过部署在不同地区的服务器来提高客户的下载速度；
  >
  >**添加Expires或Cache-Control报文头**
  >
  >对于静态内容添加Expires，将静态内容设置为永不过期；
  >
  >对于动态内容设置合适的Cache-Control，让浏览器根据条件发送请求；
  >
  >**Gzip压缩传输文件**
  >
  >可以减少70%网页内容的大小，包括脚本、样式表、图片等文件，且pdf文件可以从需要被压缩的类型中剔除，因为其本身以及压缩Gzip对其效果不大，且会浪费CPU；
  >
  >**配置ETags**
  >
  >类似一个文件摘要，服务器可以通过该摘要判断该请求内容是否需要更新，不用更新就回复304，从而避免下载整个文件；

